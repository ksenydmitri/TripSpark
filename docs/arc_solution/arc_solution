## Часть 1. Проектирование архитектуры ("To Be" — Как должно быть)

Описываем идеальную структуру нашего приложения.

1. **Тип приложения:** Mobile Application, Client–Server Architecture. Приложение выполняется на устройстве пользователя (Android), обмениваясь данными с облачным бэкендом (Firebase) и локальным хранилищем (Room + файловая система).

2. **Стратегия развертывания:** Распределенная.  
   Обоснование: Приложение разделено на клиентскую часть (Android UI + ViewModel), доменную логику (UseCases) и облачную часть (Firebase Auth, Firestore). Локально хранятся изображения и кеш данных. Компоненты физически находятся на разных узлах сети.

3. **Обоснование выбора технологий:**
   * **Kotlin + Android Jetpack:** Современный стек, высокая стабильность, поддержка Google.
   * **Firebase:** Готовая аутентификация, масштабируемая NoSQL‑БД.
   * **Room:** Локальный кеш данных и офлайн‑режим.
   * **Hilt:** Удобная и безопасная DI‑система.
   * **Coroutines + Flow:** Асинхронность и реактивность.
   * **OkHttp + собственный endpoint:** Гибкая загрузка изображений.

4. **Показатели качества:**
   * *Usability:* Плавная работа интерфейса, быстрые рекомендации.
   * *Security:* Firebase Auth, Firestore Rules, приватное файловое хранилище.
   * *Performance:* Кеширование изображений, минимизация сетевых запросов.
   * *Reliability:* Офлайн‑режим через Room и локальные файлы.

5. **Сквозная функциональность (Cross-cutting functionality):**
   * Логирование (Logcat).
   * Обработка ошибок (UI‑состояния, Toast/Snackbar).
   * Проверка прав доступа (Firebase Auth).
   * Кеширование данных (Room + File Cache).
   * DI (Hilt).
   * Асинхронность (Coroutines/Flow).

### 6. Структурная схема (To Be)

![Архитектура To Be](to_be.png)

---

## Часть 3. Сравнение и рефакторинг

### 1. Сравнение "As Is" и "To Be"

**To Be:** Чёткое разделение слоёв, слабая связность, единый подход к кешированию.  
**As Is:** Архитектура в целом следует Clean Architecture, но есть отклонения:

- ViewModel иногда знает о структуре данных Firestore.  
- Логика загрузки изображений частично размазана между слоями.  
- Не все UseCase‑ы полностью изолируют Presentation от Data.

### 2. Отличия и их причины

Основное отличие — неполное соблюдение архитектурного паттерна (Clean Architecture).

**Причина:** Проект развивался итеративно, некоторые функции добавлялись быстрее, чем архитектура успевала адаптироваться. Firebase SDK сильно связан с Android‑слоем, что усложняет изоляцию.

### 3. Пути улучшения (Рефакторинг)

Чтобы привести систему к идеалу ("To Be"), нужно:

- **Усилить разделение слоёв:**
  - убрать прямые зависимости ViewModel → Firestore;
  - вынести сетевую логику в UseCases/Repository.

- **Унифицировать работу с изображениями:**
  - использовать единый метод `getOrFetchImage()` для всех экранов;
  - не передавать URL напрямую в UI.

- **Улучшить структуру Data‑слоя:**
  - выделить отдельные интерфейсы для Remote и Local источников;
  - использовать sealed‑классы для ошибок.

- **Применить принцип "Single Responsibility":**
  - разделить слишком большие классы и функции.

### Вывод

Целевая архитектура TripSpark ("To Be") основана на Clean Architecture и обеспечивает высокую масштабируемость, удобство сопровождения и производительность. Текущая реализация ("As Is") в целом следует этим принципам, но содержит упрощения. Рефакторинг позволит приблизить систему к идеальной архитектуре, улучшить читаемость кода и повысить качество приложения.


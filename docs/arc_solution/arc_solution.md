## Часть 1. Проектирование архитектуры ("To Be" — Как должно быть)

Описываем идеальную структуру нашего приложения.

1. **Тип приложения:** Mobile Application, Client–Server Architecture. Приложение выполняется на устройстве пользователя (Android), обмениваясь данными с облачным бэкендом (Firebase) и локальным хранилищем (Room + файловая система).

2. **Стратегия развертывания:** Распределенная.  
   Обоснование: Приложение разделено на клиентскую часть (Android UI + ViewModel), доменную логику (UseCases) и облачную часть (Firebase Auth, Firestore). Локально хранятся изображения и кеш данных. Компоненты физически находятся на разных узлах сети.

3. **Обоснование выбора технологий:**
    * **Kotlin + Android Jetpack:** Современный стек, высокая стабильность, поддержка Google.
    * **Firebase:** Готовая аутентификация, масштабируемая NoSQL‑БД.
    * **Room:** Локальный кеш данных и офлайн‑режим.
    * **Hilt:** Удобная и безопасная DI‑система.
    * **Coroutines + Flow:** Асинхронность и реактивность.
    * **OkHttp + собственный endpoint:** Гибкая загрузка изображений.

4. **Показатели качества:**
    * *Usability:* Плавная работа интерфейса, быстрые рекомендации.
    * *Security:* Firebase Auth, Firestore Rules, приватное файловое хранилище.
    * *Performance:* Кеширование изображений, минимизация сетевых запросов.
    * *Reliability:* Офлайн‑режим через Room и локальные файлы.

5. **Сквозная функциональность (Cross-cutting functionality):**
    * Логирование (Logcat).
    * Обработка ошибок (UI‑состояния, Toast/Snackbar).
    * Проверка прав доступа (Firebase Auth).
    * Кеширование данных (Room + File Cache).
    * DI (Hilt).
    * Асинхронность (Coroutines/Flow).

### 6. Структурная схема (To Be)

![Структурная схема To Be](to_be.png)

---

## Часть 2. Анализ архитектуры ("As Is" — Как реализовано сейчас)

Мы используем «обратное проектирование». Хотя в проекте присутствуют разные файлы, логика частично пересекается между слоями.

**Диаграмма классов/модулей (As Is):**

![Диаграмма классов As Is](as_is.png)

---

## Часть 3. Сравнение и рефакторинг

### 1. Сравнение "As Is" и "To Be"

* **To Be:** Предполагает четкое разделение на физические слои и, возможно, разные файлы/модули.  
* **As Is:** Архитектура в целом следует Clean Architecture, но есть отклонения:
    * ViewModel иногда знает о структуре данных Firestore.
    * Логика загрузки изображений частично размазана между слоями.
    * Не все UseCase‑ы полностью изолируют Presentation от Data.

### 2. Отличия и их причины

Основное отличие — **неполное соблюдение архитектурного паттерна (Clean Architecture)**.

*Причина:* Проект развивался итеративно, некоторые функции добавлялись быстрее, чем архитектура успевала адаптироваться. Firebase SDK сильно связан с Android‑слоем, что усложняет изоляцию.

### 3. Пути улучшения (Рефакторинг)

Чтобы привести систему к идеалу ("To Be"), нужно:

1. **Усилить разделение слоёв:**
    * убрать прямые зависимости ViewModel → Firestore;
    * вынести сетевую логику в UseCases/Repository.

2. **Унифицировать работу с изображениями:**
    * использовать единый метод `getOrFetchImage()` для всех экранов;
    * не передавать URL напрямую в UI.

3. **Улучшить структуру Data‑слоя:**
    * выделить отдельные интерфейсы для Remote и Local источников;
    * использовать sealed‑классы для ошибок.

4. **Применить принцип "Single Responsibility":**
    * разделить слишком большие классы и функции.

---

## Вывод

Целевая архитектура TripSpark ("To Be") основана на Clean Architecture и обеспечивает высокую масштабируемость, удобство сопровождения и производительность. Текущая реализация ("As Is") в целом следует этим принципам, но содержит упрощения. Рефакторинг позволит приблизить систему к идеальной архитектуре, улучшить читаемость кода и повысить качество приложения.


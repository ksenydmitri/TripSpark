# Лабораторная работа №3  
## Исследование архитектурного решения (TripSpark)

---

# Часть 1. Проектирование архитектуры (“To Be” — как должно быть)

Ниже представлена целевая архитектура мобильного приложения TripSpark на высоком уровне абстракции.

## 1. Тип приложения

Мобильное клиент‑серверное приложение (Android, Kotlin) с офлайн‑поддержкой. Клиент работает на устройстве пользователя, данные хранятся в облаке (Firebase) и частично локально (Room + файловая система).

## 2. Стратегия развёртывания

Распределённая архитектура.

- Клиент: Android‑приложение, распространяемое через APK/Google Play.  
- Сервер: Firebase (Auth, Firestore), собственный worker endpoint для загрузки изображений.  
- Локальная часть: Room Database + файловая система (`filesDir/images`) для кеша изображений.

Компоненты физически находятся на разных узлах сети и взаимодействуют через HTTPS.

## 3. Обоснование выбора технологий

- Kotlin + Android Jetpack (ViewModel, StateFlow, Navigation) — современный стек, высокая стабильность.  
- Clean Architecture + MVVM — слабая связность, тестируемость, удобство сопровождения.  
- Hilt (DI) — автоматическое управление зависимостями.  
- Firebase Auth + Firestore — готовая авторизация, масштабируемая NoSQL‑БД.  
- Room — локальный кеш данных и офлайн‑режим.  
- OkHttp + worker endpoint — гибкая загрузка изображений.  
- Файловая система Android — быстрый доступ к изображениям, офлайн‑режим.

## 4. Показатели качества

- Производительность — кеширование изображений и данных, минимизация сетевых запросов.  
- Масштабируемость — Firestore автоматически масштабируется.  
- Надёжность — локальный кеш Room + File Cache.  
- Безопасность — Firebase Auth, Firestore Rules, приватное файловое хранилище.  
- Удобство сопровождения — Clean Architecture, DI, разделение ответственности.  
- Удобство использования — отзывчивый UI, плавная работа рекомендаций.

## 5. Сквозная функциональность (Cross‑cutting concerns)

- Логирование (Logcat).  
- Обработка ошибок (UI‑состояния, Toast/Snackbar).  
- Авторизация и проверка прав доступа (Firebase Auth).  
- Кеширование данных (Room + File Cache).  
- DI (Hilt).  
- Асинхронность (Coroutines + Flow).

## 6. Структурная схема архитектуры (To Be)



---

# Часть 2. Анализ архитектуры (“As Is” — как реализовано сейчас)

Используя реальный код TripSpark, можно выделить следующие фактические компоненты.

## Диаграмма классов/модулей (As Is)


---

# Часть 3. Сравнение и рефакторинг

## 1. Сравнение “As Is” и “To Be”

- To Be — чёткое разделение слоёв, слабая связность, единый подход к кешированию.  
- As Is — архитектура в целом соответствует Clean Architecture, но есть отклонения:
  - ViewModel иногда знает слишком много о структуре данных.  
  - Логика загрузки изображений частично размазана между слоями.  
  - Не все UseCase‑ы полностью изолируют Presentation от Data.

## 2. Отличия и причины

- Эволюционное развитие проекта — сначала реализовывались фичи, затем архитектура.  
- Ограничения времени — некоторые функции реализованы быстрее, чем идеально.  
- Firebase SDK сильно связан с Android‑слоем, что усложняет полную изоляцию Data‑слоя.

## 3. Пути улучшения (Рефакторинг)

- Усилить разделение слоёв:
  - убрать прямые зависимости ViewModel → Firestore;  
  - вынести всю сетевую логику в UseCases/Repository.

- Унифицировать работу с изображениями:
  - использовать только `getOrFetchImage()` для всех экранов;  
  - не передавать URL напрямую в UI.

- Улучшить структуру Data‑слоя:
  - выделить отдельные интерфейсы для Remote и Local источников;  
  - использовать sealed‑классы для ошибок.

- Применить принципы SOLID:
  - Single Responsibility — разделить слишком большие классы;  
  - Dependency Inversion — UI должен зависеть только от интерфейсов.

---

# Вывод

Целевая архитектура TripSpark (“To Be”) основана на Clean Architecture и обеспечивает высокую масштабируемость,удобство сопровождения и производительность. Текущая реализация (“As Is”) в целом следует этим принципам, но содержит несколько упрощений, связанных с Firebase и быстрым развитием функциональности. Рефакторинг, предложенный выше, позволит приблизить систему к идеальной архитектуре, улучшить читаемость кода и повысить качество приложения.
